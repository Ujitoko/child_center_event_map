name: Daily Scrape

on:
  schedule:
    # JST 06:00 = UTC 21:00 (previous day)
    - cron: '0 21 * * *'
  workflow_dispatch: # manual trigger

permissions:
  contents: write

jobs:
  scrape:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Wake up Render service
        run: |
          BASE_URL="${{ secrets.RENDER_URL }}"
          BASE_URL="${BASE_URL%/}"
          echo "Waking up ${BASE_URL}..."
          curl -s --retry 5 --retry-delay 10 --retry-all-errors --max-time 120 \
            "${BASE_URL}/api/health" -o /dev/null -w "Health: HTTP %{http_code}\n"

      - name: Trigger refresh and poll until complete
        run: |
          BASE_URL="${{ secrets.RENDER_URL }}"
          BASE_URL="${BASE_URL%/}"

          # Step 1: Trigger the background refresh
          echo "Triggering refresh..."
          HTTP_CODE=$(curl -s --max-time 60 \
            "${BASE_URL}/api/events?refresh=1&days=30" \
            -o /tmp/trigger_response.json -w "%{http_code}")
          echo "Trigger response: HTTP ${HTTP_CODE}"
          if [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
            echo "::error::Refresh trigger failed with HTTP ${HTTP_CODE}"
            exit 1
          fi

          # Step 2: Poll until refresh_in_progress becomes false
          MAX_POLLS=60        # 60 polls
          POLL_INTERVAL=60    # 60 seconds each = up to 60 minutes
          POLL=0
          while [ $POLL -lt $MAX_POLLS ]; do
            sleep $POLL_INTERVAL
            POLL=$((POLL + 1))
            echo "Poll ${POLL}/${MAX_POLLS}..."

            set +e
            HTTP_CODE=$(curl -s --max-time 30 \
              "${BASE_URL}/api/events?days=30" \
              -o /tmp/poll_response.json -w "%{http_code}")
            CURL_EXIT=$?
            set -e

            if [ "$CURL_EXIT" -ne 0 ] || [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
              echo "::warning::Poll failed (curl=${CURL_EXIT}, HTTP=${HTTP_CODE}), retrying..."
              continue
            fi

            IN_PROGRESS=$(python3 -c "import json; d=json.load(open('/tmp/poll_response.json')); print(d.get('refresh_in_progress', False))" 2>/dev/null || echo "Unknown")
            ITEMS=$(python3 -c "import json; d=json.load(open('/tmp/poll_response.json')); print(d.get('count', 0))" 2>/dev/null || echo "0")
            SAVED_AT=$(python3 -c "import json; d=json.load(open('/tmp/poll_response.json')); print(d.get('snapshot_saved_at', 'unknown'))" 2>/dev/null || echo "unknown")
            echo "  refresh_in_progress=${IN_PROGRESS}, count=${ITEMS}, saved_at=${SAVED_AT}"

            if [ "$IN_PROGRESS" = "False" ] && [ "$ITEMS" -gt 0 ] 2>/dev/null; then
              echo "Refresh complete! ${ITEMS} items"
              cp /tmp/poll_response.json data/events_snapshot.json
              echo "Snapshot saved: ${ITEMS} items"
              exit 0
            fi
          done

          echo "::error::Refresh did not complete within $((MAX_POLLS * POLL_INTERVAL / 60)) minutes"
          exit 1

      - name: Commit snapshot
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add data/events_snapshot.json
          if git diff --cached --quiet; then
            echo "No changes to commit"
          else
            git commit -m "chore: update events snapshot $(date -u +%Y-%m-%d)"
            git push
          fi
